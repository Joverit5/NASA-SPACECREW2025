<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NASA SPATIUM — Multiplayer + Chat</title>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

  <style>
    :root{
      --bg: #0a0a14;
      --panel: #0f2130;
      --muted: #9aa7b2;
      --accent: #66ccff;
      --chat-width: 360px;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: "Segoe UI", Roboto, system-ui, sans-serif;
      background: var(--bg);
      color: #e6eef6;
      -webkit-font-smoothing:antialiased;
    }

    .app {
      display: flex;
      height: 100vh;
      gap: 12px;
      box-sizing: border-box;
      padding: 12px;
    }

    #game-wrapper {
      flex: 1 1 auto;
      position: relative;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
      min-width: 300px;
    }

    #ui-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 30;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(4px);
      border-radius: 8px;
      padding: 10px 12px;
      color: #eaf6ff;
      min-width: 220px;
    }
    #game-container {
      width: 100%;
      height: 100%;
    }
    #playerStats {
      font-size: 12px;
      color: var(--muted);
    }
    .spacer {
      flex: 1;
    }
    .stat-item {
      font-size: 12px;
      color: var(--muted);
    }
    #ui-overlay .time { color: var(--accent); font-weight:700; font-size:18px; text-align:center; }
    #eventLog { position:absolute; right:12px; bottom:12px; width:300px; max-height:220px; overflow:auto; z-index:30; background: rgba(0,0,0,0.45); border-radius:8px; padding:10px; color:#dbeeff; }

    #chat-panel {
      width: var(--chat-width);
      max-width: 40%;
      background: linear-gradient(180deg,#0f2433, #07121a);
      border-radius: 10px;
      padding: 14px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    #chat-header {
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:700;
      color:var(--accent);
    }
    #status { font-size:12px; color:var(--muted); }

    #messages {
      flex:1 1 auto;
      background: rgba(10,16,24,0.6);
      border-radius:8px;
      padding:10px;
      overflow:auto;
    }
    .message{ margin:6px 0; padding:8px; border-radius:6px; max-width:100%; word-break:break-word; font-size:13px; }
    .you{ background:#052f2a; color:#bfffe6; align-self:flex-end; }
    .other{ background:#372a10; color:#ffd97a; align-self:flex-start; }
    .system{ text-align:center; color:var(--muted); font-style:italic; background:transparent; padding:6px; }

    #input-container { display:flex; gap:8px; margin-top:6px; }
    #chat-input { flex:1; padding:10px; border-radius:8px; border:1px solid #223; background:#07121a; color:#eaf6ff; }
    #chat-send { background:var(--accent); border:none; padding:10px 12px; border-radius:8px; color:#012; font-weight:700; cursor:pointer; }

    @media (max-width:900px){
      .app{ flex-direction:column; padding:8px; }
      #chat-panel{ width:100%; max-width:none; height:320px; }
      #game-wrapper{ height:60vh; min-height:360px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div id="game-wrapper">
      <div id="game-container"></div>

      <div id="ui-overlay">
        <div class="time" id="gameTime">00:00</div>
        <div id="playerStats"></div>
      </div>

      <div id="eventLog"><strong>Event Log</strong><div id="eventList"></div></div>
    </div>

    <aside id="chat-panel" role="complementary" aria-label="Chat">
      <div id="chat-header">
        <span>Chat Espacial</span>
        <div class="spacer"></div>
        <div id="status" title="Estado de conexion">Conectando...</div>
      </div>

      <div id="messages" aria-live="polite" aria-atomic="false"></div>

      <div id="input-container">
        <input id="chat-input" placeholder="Escribe un mensaje..." disabled />
        <button id="chat-send" disabled>Enviar</button>
      </div>
    </aside>
  </div>

  <script>
  (function(){
    const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
    const SERVER_URL = isLocal ? (location.origin) : location.origin;
    const socket = io(SERVER_URL);
    window.socket = socket; 

    const sessionId = "sala-demo";

    const statusDiv = document.getElementById("status");
    const messagesDiv = document.getElementById("messages");
    const inputEl = document.getElementById("chat-input");
    const sendBtn = document.getElementById("chat-send");

    const gameTimeEl = document.getElementById("gameTime");
    const playerStatsEl = document.getElementById("playerStats");
    const eventList = document.getElementById("eventList");

    let playerId = null;
    let playerName = null;
    let isConnected = false;
    let isJoining = false;

    function promptForName(){
      let name = prompt("Tu nombre (1-20 caracteres):");
      if (!name) return promptForName();
      name = name.trim();
      if (name.length === 0 || name.length > 20) return promptForName();
      return name;
    }

    function setStatus(text, cls = ''){
      statusDiv.textContent = text;
      statusDiv.className = cls;
    }

    function addSystem(text){
      const d = document.createElement('div');
      d.className = 'message system';
      d.textContent = text;
      messagesDiv.appendChild(d);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function addMessage(msg){
      const d = document.createElement('div');
      d.className = 'message ' + (msg.playerId === playerId ? 'you' : 'other');
      d.textContent = (msg.playerId === playerId ? '[Tu] ' : `[${msg.playerName}] `) + msg.text;
      messagesDiv.appendChild(d);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function showError(text){
      const d = document.createElement('div');
      d.className = 'message system';
      d.style.color = '#ff6b6b';
      d.textContent = '❌ ' + text;
      messagesDiv.appendChild(d);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function attemptJoin(name){
      if (isJoining) return;
      isJoining = true;
      setStatus(`Conectando como ${name}...`);
      socket.emit('join_session', { sessionId, player: { name } });
    }

    socket.on('connect', () => {
      console.log('socket connected', socket.id);
      playerName = promptForName();
      attemptJoin(playerName);
    });

    socket.on('join_success', (data) => {
      playerId = data.playerId;
      isConnected = true;
      isJoining = false;
      setStatus(`Conectado: ${data.playerName}`, 'connected');
      inputEl.disabled = false;
      sendBtn.disabled = false;
      addSystem(`Te has unido a ${data.sessionId} como ${data.playerName}`);
    });

    socket.on('join_rejected', (data) => {
      isJoining = false;
      showError(data.message);
      setStatus(data.message, 'error');
      if (data.reason === 'room_full') {
        inputEl.disabled = true;
        sendBtn.disabled = true;
        addSystem("Sala llena. Intenta mas tarde.");
        setTimeout(()=> socket.disconnect(), 400);
        return;
      }
      if (data.reason === 'name_taken') {
        setTimeout(()=> {
          const newName = promptForName();
          attemptJoin(newName);
        }, 300);
      }
    });

    socket.on('chat_history', (messages) => {
      if (!messages || !messages.length) return;
      addSystem(`--- Historial (${messages.length}) ---`);
      messages.forEach(m => addMessage(m));
    });

    socket.on('chat_message_broadcast', (msg) => {
      addMessage(msg);
    });

    socket.on('player_joined', (data) => {
      addSystem(`${data.name} se ha unido a la sala`);
    });

    socket.on('player_left', (data) => {
      addSystem(`${data.name} ha salido de la sala`);
    });

    socket.on('chat_error', (data) => {
      showError(data.message || "Error en chat");
      setStatus(`Error: ${data.message}`, 'error');
      inputEl.disabled = true;
      sendBtn.disabled = true;
      isConnected = false;
    });

    socket.on('disconnect', () => {
      setStatus('Desconectado', 'error');
      inputEl.disabled = true;
      sendBtn.disabled = true;
      addSystem('Conexion perdida con el servidor');
    });

    socket.on('connect_error', (err) => {
      setStatus('Error de conexion', 'error');
      showError('No se pudo conectar al servidor');
    });

    sendBtn.addEventListener('click', () => {
      sendChat();
    });
    inputEl.addEventListener('keypress', (ev) => {
      if (ev.key === 'Enter') {
        ev.preventDefault(); // Prevenir salto de línea
        sendChat();
      }
    });

    function sendChat(){
      if (!isConnected || !playerId) return;
      const text = inputEl.value.trim();
      if (!text) return;
      socket.emit('chat_message', { sessionId, playerId, text });
      inputEl.value = '';
    }

    function addEventToLog(message){
      const item = document.createElement('div');
      item.className = 'event-item';
      const t = new Date().toLocaleTimeString();
      item.textContent = `[${t}] ${message}`;
      eventList.insertBefore(item, eventList.firstChild);
      while (eventList.children.length > 12) eventList.removeChild(eventList.lastChild);
    }

    // ============================================
    // PHASER - CORRECCION DE SINCRONIZACION
    // ============================================
    let myPlayerId = null;
    let otherPlayers = {};
    let currentGameTime = 0;

    const config = {
      type: Phaser.AUTO,
      width: 1100,
      height: 700,
      parent: 'game-container',
      backgroundColor: '#000000',
      scene: { preload, create, update },
      physics: { default: 'arcade', arcade: { debug: false } }
    };
    const game = new Phaser.Game(config);

    window.addEventListener('keydown', (e) => {
      const chatInput = document.getElementById('chat-input');
      // Si el foco está en el input del chat...
      if (document.activeElement === chatInput) {
        // Evita que Phaser o el navegador bloqueen la barra espaciadora
        e.stopImmediatePropagation();
        if (e.code === 'Space') {
          e.preventDefault(); // evita que el scroll o Phaser lo intercepte
          chatInput.value += ' '; // inserta el espacio manualmente
        }
      }
    });

    function preload(){}
    
    function create(){
      const scene = this;
      
      // Background grid
      const graphics = this.add.graphics();
      graphics.lineStyle(1, 0x16213e, 0.25);
      for (let x=0; x<1200; x+=50) graphics.lineBetween(x,0,x,800);
      for (let y=0; y<800; y+=50) graphics.lineBetween(0,y,1200,y);

      this.add.text(550, 16, 'NASA SPATIUM - Multiplayer', { 
        fontSize:'22px', 
        color:'#66ccff', 
        fontFamily:'Segoe UI' 
      }).setOrigin(0.5,0);

      scene.player = null;
      scene.cursors = this.input.keyboard.createCursorKeys();
      scene.keys = this.input.keyboard.addKeys({ 
        SHIFT: Phaser.Input.Keyboard.KeyCodes.SHIFT 
      });

      const chatInput = document.getElementById('chat-input');

      chatInput.addEventListener('focus', () => {
        // Desactivar captura de teclado de Phaser
        scene.input.keyboard.enabled = false;
      });
      
      chatInput.addEventListener('blur', () => {
        // Reactivar captura de teclado de Phaser
        scene.input.keyboard.enabled = true;
      });

      const canvas = scene.game.canvas;
      canvas.addEventListener("pointerdown", () => {
        if (document.activeElement === chatInput) {
          chatInput.blur();
        }
      });

      socket.on('connect', () => {
        myPlayerId = socket.id;
        console.log('Game socket connected', myPlayerId);
        addEventToLog('Conectado al servidor (juego)');
      });

      // CORRECCION: Interpolar TODOS los jugadores desde el servidor
      socket.on('state:update', (state) => {
        currentGameTime = state.gameTime || 0;
        updateGameTimeUI(currentGameTime);
        
        Object.values(state.players || {}).forEach(pd => {
          if (pd.id === myPlayerId) {
            // Tu jugador - crear o interpolar
            if (!scene.player) {
              scene.player = createPlayer(scene, pd, true);
            } else {
              // Interpolar suavemente a la posicion del servidor
              scene.tweens.add({
                targets: scene.player.sprite,
                x: pd.x,
                y: pd.y,
                duration: 50,
                ease: 'Linear'
              });
              scene.player.nameText.x = pd.x;
              scene.player.nameText.y = pd.y - 28;
            }
            updatePlayerStatsUI(pd);
          } else {
            // Otros jugadores
            if (!otherPlayers[pd.id]) {
              otherPlayers[pd.id] = createPlayer(scene, pd, false);
            }
            updateOtherPlayer(scene, pd);
          }
        });
        
        // Remover jugadores desconectados
        Object.keys(otherPlayers).forEach(id => { 
          if (!state.players[id]) { 
            otherPlayers[id].sprite.destroy(); 
            otherPlayers[id].nameText.destroy(); 
            delete otherPlayers[id]; 
          }
        });
      });

      socket.on('game:event', (ev) => {
        addEventToLog(ev.type || 'evento');
        if (ev.type === 'storm_incoming') scene.cameras.main.shake(500, 0.006);
      });
    }

    function update(){
      if (!this.player) return;
      
      const speed = this.keys.SHIFT.isDown ? 8 : 5;
      let dx = 0;
      let dy = 0;
      let moved = false;
      
      if (this.cursors.up.isDown) { dy = -1; moved = true; }
      if (this.cursors.down.isDown) { dy = 1; moved = true; }
      if (this.cursors.left.isDown) { dx = -1; moved = true; }
      if (this.cursors.right.isDown) { dx = 1; moved = true; }

      if (moved) {
        // Normalizar diagonal
        if (dx !== 0 && dy !== 0) { 
          const m = Math.sqrt(dx*dx + dy*dy); 
          dx = (dx/m) * speed; 
          dy = (dy/m) * speed; 
        } else { 
          dx *= speed; 
          dy *= speed; 
        }
        
        // CORRECCION: SOLO enviar al servidor, NO mover localmente
        const direction = getDirection(dx, dy);
        socket.emit('player:move', { dx, dy, direction });
      }
    }

    function createPlayer(scene, pd, local){
      const key = 'player_' + pd.id;
      if (!scene.textures.exists(key)) {
        const g = scene.add.graphics();
        const color = local ? 0x3498db : 0xe74c3c;
        g.fillStyle(color, 1); 
        g.fillCircle(20, 20, 15);
        g.lineStyle(2, 0xffffff, 1); 
        g.strokeCircle(20, 20, 15);
        g.generateTexture(key, 40, 40); 
        g.destroy();
      }
      const sprite = scene.add.sprite(pd.x || 200, pd.y || 200, key);
      const short = (pd.id || 'n').slice(0, 6);
      const nameText = scene.add.text(sprite.x, sprite.y - 28, short, { 
        fontSize: '12px', 
        color: local ? '#bfefff' : '#ffd6a6', 
        backgroundColor: '#000', 
        padding: {x: 4, y: 2}
      }).setOrigin(0.5);
      
      return { sprite, nameText, data: pd };
    }

    function updateOtherPlayer(scene, pd){
      const p = otherPlayers[pd.id];
      if (!p) return;
      scene.tweens.add({ 
        targets: [p.sprite], 
        x: pd.x, 
        y: pd.y, 
        duration: 50, 
        ease: 'Linear' 
      });
      p.nameText.x = pd.x;
      p.nameText.y = pd.y - 28;
    }

    function getDirection(dx, dy){
      if (dy < 0 && dx === 0) return 'up';
      if (dy > 0 && dx === 0) return 'down';
      if (dx < 0 && dy === 0) return 'left';
      if (dx > 0 && dy === 0) return 'right';
      if (dx < 0 && dy < 0) return 'up-left';
      if (dx > 0 && dy < 0) return 'up-right';
      if (dx < 0 && dy > 0) return 'down-left';
      if (dx > 0 && dy > 0) return 'down-right';
      return 'idle';
    }

    function updateGameTimeUI(seconds){
      const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
      const secs = (seconds % 60).toString().padStart(2, '0');
      gameTimeEl.textContent = `${mins}:${secs}`;
    }

    function updatePlayerStatsUI(pd){
      playerStatsEl.innerHTML = `
        <div class="stat-item">Vida: ${pd.health}%</div>
        <div class="stat-item">O2: ${pd.oxygen}%</div>
      `;
    }

    // ============================================
    // SISTEMA DE EVENTOS DE SIMULACIÓN
    // ============================================
    const eventsContainer = document.createElement('div');
    eventsContainer.id = 'events-display';
    eventsContainer.style.cssText = `
      position: absolute;
      top: 12px;
      right: 12px;
      width: 300px;
      max-height: 400px;
      overflow-y: auto;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(6px);
      border-radius: 10px;
      padding: 12px;
      z-index: 40;
      color: #eaf6ff;
    `;
    document.getElementById('game-wrapper').appendChild(eventsContainer);

    const activeEventsMap = new Map();

    // Escuchar cuando un evento es disparado
    socket.on('event:triggered', (event) => {
      console.log('Event triggered:', event);
      activeEventsMap.set(event.id, event);
      updateEventsUI();
      
      // Agregar al log
      addEventToLog(`${event.config.icon} ${event.config.name}`);
      
      // Efecto visual
      const scene = game.scene.scenes[0];
      if (scene && scene.cameras) {
        scene.cameras.main.flash(300, 255, 100, 100);
      }
    });

    // Escuchar cuando un evento se resuelve
    socket.on('event:resolved', (data) => {
      console.log('Event resolved:', data);
      activeEventsMap.delete(data.eventId);
      updateEventsUI();
      addEventToLog(`✅ Evento resuelto`);
    });

    // Actualizar UI de eventos activos
    function updateEventsUI() {
      const container = eventsContainer;
      
      if (activeEventsMap.size === 0) {
        container.innerHTML = '<div style="text-align:center; color:#9aa7b2; font-size:12px;">Sin eventos activos</div>';
        return;
      }

      let html = '<div style="font-weight:700; margin-bottom:8px; color:#66ccff;">📡 Eventos Activos</div>';
      
      activeEventsMap.forEach((event, eventId) => {
        const timeLeft = Math.max(0, Math.ceil((event.endTime - Date.now()) / 1000));
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        
        html += `
          <div style="
            background: rgba(255,255,255,0.05);
            border-left: 3px solid #${event.config.color.toString(16)};
            padding: 8px;
            margin: 6px 0;
            border-radius: 6px;
            font-size: 12px;
          ">
            <div style="font-weight:700; margin-bottom:4px;">
              ${event.config.icon} ${event.config.name}
            </div>
            <div style="color:#9aa7b2; font-size:11px; margin-bottom:4px;">
              ${event.config.description}
            </div>
            <div style="color:#ffd93d; font-size:11px;">
              ⏱️ ${minutes}:${seconds.toString().padStart(2, '0')}
            </div>
            ${event.config.requiresPlayerAction ? `
              <button onclick="window.resolveEvent('${eventId}')" style="
                margin-top: 6px;
                background: #66ccff;
                border: none;
                padding: 4px 8px;
                border-radius: 4px;
                color: #000;
                font-size: 11px;
                cursor: pointer;
                font-weight: 700;
              ">Resolver</button>
            ` : ''}
          </div>
        `;
      });
      
      container.innerHTML = html;
    }

    // Función global para resolver eventos
    window.resolveEvent = function(eventId) {
      console.log('Resolviendo evento:', eventId);
      socket.emit('event:resolve', { eventId });
    };

    // Solicitar eventos activos al conectar
    socket.on('connect', () => {
      setTimeout(() => {
        socket.emit('event:get_active');
      }, 500);
    });

    // Recibir lista de eventos activos
    socket.on('event:active_list', (events) => {
      console.log('Active events received:', events);
      activeEventsMap.clear();
      events.forEach(event => {
        activeEventsMap.set(event.id, event);
      });
      updateEventsUI();
    });

    // Inicializar UI
    updateEventsUI();

    window._spatium = { socket };

  })();
  </script>
</body>
</html>